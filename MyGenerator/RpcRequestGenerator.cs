using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MyGenerator
{
    [Generator]
    public class RpcRequestGenerator : ISourceGenerator
    {
        internal const string AttribName = "RpcRequest";
        public const string RpcRequestAttribContent = @"
namespace Rpc
{
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public sealed class RpcRequestAttribute : System.Attribute {
        public RpcRequestAttribute() {}
    }
}
";
        public void Initialize(GeneratorInitializationContext context)
        {
#if DEBUG
            // while (!System.Diagnostics.Debugger.IsAttached)
            //     System.Threading.Thread.Sleep(500);
#endif

            // Register a factory that can create our custom syntax receiver
            context.RegisterForSyntaxNotifications(() => new MySyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
#if DEBUG
            // while (!System.Diagnostics.Debugger.IsAttached)
            //     System.Threading.Thread.Sleep(500);
#endif
            context.AddSource(nameof(RpcRequestAttribContent), RpcRequestAttribContent);

            MySyntaxReceiver rx = (MySyntaxReceiver)context.SyntaxContextReceiver!;
            foreach (var request in rx.Requests)
            {

                // TODO: template serialize/deserialize methods

                var generated =
@$"
/// <summary>
/// autogenerated
/// </summary> 
public partial class {request.ClassName}
{{
    public byte[] RpcRequest_{request.Name}(byte[] request) 
    {{
        var data = System.BitConverter.ToString(request);
        return System.BitConverter.GetBytes(this.{request.Name}(data));
    }}
}}";

                if (!string.IsNullOrEmpty(request.ClassNamespace))
                    generated = $"namespace {request.ClassNamespace};\n{generated}";

                context.AddSource($"RpcRequest{request.Name}", generated);
            }
        }
    }

    record RpcRequest
    {
        public string Name = string.Empty;
        public string TIn = string.Empty;
        public string TOut = string.Empty;
        public string ClassName = string.Empty;
        public string ClassNamespace = string.Empty;
    }

    class MySyntaxReceiver : ISyntaxContextReceiver
    {
        public List<RpcRequest> Requests = new List<RpcRequest>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // find all valid RpcRequest attributes
            if (context.Node is AttributeSyntax attrib
                && context.SemanticModel.GetTypeInfo( attrib).Type?.ToDisplayString() == RpcRequestGenerator.AttribName)
            {

            }

            if (context.Node is MethodDeclarationSyntax mds)
            {
                foreach (var attributeList in mds.AttributeLists)
                {
                    foreach (var attribute in attributeList.Attributes)
                    {
                        if (attribute.Name.ToString() == RpcRequestGenerator.AttribName)
                        {
                            if (mds.ParameterList.Parameters.Count == 1
                                && mds.ReturnType.ToString() != "void"
                            )
                            {
                                var cds = (mds.Parent as ClassDeclarationSyntax);
                                Requests.Add(new RpcRequest()
                                {
                                    Name = mds.Identifier.Text,
                                    TIn = mds.ParameterList.Parameters[0].Type?.ToString() ?? string.Empty,
                                    TOut = mds.ReturnType.ToString(),
                                    ClassName = cds?.Identifier.Text ?? "",
                                    ClassNamespace = SyntaxNodeHelper.GetNamespaceName(cds),
                                });
                            }
                        }
                    }
                }
            }
        }
    }

    /// <summary>
    /// https://stackoverflow.com/a/23249021/7468485
    /// </summary>
    static class SyntaxNodeHelper
    {
        public static string GetNamespaceName(SyntaxNode? syntaxNode)
        {
            if (syntaxNode is not ClassDeclarationSyntax classDeclarationSyntax)
                return string.Empty;

            if (!SyntaxNodeHelper.TryGetParentSyntax(classDeclarationSyntax, out NamespaceDeclarationSyntax namespaceDeclarationSyntax))
                return String.Empty;

            var namespaceName = namespaceDeclarationSyntax.Name.ToString();
            return namespaceName;
        }

        public static bool TryGetParentSyntax<T>(SyntaxNode syntaxNode, out T result)
            where T : SyntaxNode
        {
            // set defaults
            result = null;

            if (syntaxNode == null)
            {
                return false;
            }

            try
            {
                syntaxNode = syntaxNode.Parent;

                if (syntaxNode == null)
                {
                    return false;
                }

                if (syntaxNode.GetType() == typeof (T))
                {
                    result = syntaxNode as T;
                    return true;
                }

                return TryGetParentSyntax<T>(syntaxNode, out result);
            }
            catch
            {
                return false;
            }
        }
    }
}

